using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using Newtonsoft.Json;
using OfficeOpenXml;

class Program
{
    static async Task Main(string[] args)
    {
        int batchSize = 5; // Set batch size

        // Ask for input and output paths
        Console.WriteLine("Enter the full path of the Excel file containing the search IDs:");
        string excelFilePath = Console.ReadLine();

        if (!File.Exists(excelFilePath))
        {
            Console.WriteLine("Error: Excel file not found.");
            return;
        }

        Console.WriteLine("Enter your GitHub Personal Access Token:");
        string token = Console.ReadLine();

        Console.WriteLine("Enter the output directory:");
        string outputDirectory = Console.ReadLine();

        if (!Directory.Exists(outputDirectory))
        {
            Console.WriteLine("Error: Output directory does not exist.");
            return;
        }

        // Read IDs from Excel
        Console.WriteLine("Reading IDs from Excel...");
        var ids = ReadIdsFromExcel(excelFilePath);
        Console.WriteLine($"Found {ids.Count} IDs to process.");

        var allResults = new List<SearchResultWithId>();

        // Process in batches
        for (int i = 0; i < ids.Count; i += batchSize)
        {
            var batch = ids.Skip(i).Take(batchSize).ToList();
            Console.WriteLine($"Processing batch {i / batchSize + 1}: {string.Join(", ", batch)}");

            var batchResults = await Task.WhenAll(batch.Select(id => SearchGitHub(id, token)));

            foreach (var result in batchResults)
            {
                if (result.Count > 0)
                    Console.WriteLine($"✅ Retrieved {result.Count} results for batch {i / batchSize + 1}");
                else
                    Console.WriteLine($"❌ No results found for batch {i / batchSize + 1}");
                
                allResults.AddRange(result);
            }
        }

        Console.WriteLine("Writing results to Excel...");
        string outputFilePath = Path.Combine(outputDirectory, "GitHubSearchResults.xlsx");

        // Debugging: Print number of results before writing
        Console.WriteLine($"Total results to write: {allResults.Count}");

        WriteResultsToExcel(allResults, outputFilePath);
        Console.WriteLine($"Results saved at {outputFilePath}");
    }

    /// <summary>
    /// Reads search IDs from an Excel file.
    /// </summary>
    static List<string> ReadIdsFromExcel(string excelFilePath)
    {
        var ids = new List<string>();
        ExcelPackage.LicenseContext = LicenseContext.NonCommercial;

        using (var package = new ExcelPackage(new FileInfo(excelFilePath)))
        {
            var worksheet = package.Workbook.Worksheets[0];
            int rows = worksheet.Dimension.Rows;

            for (int row = 1; row <= rows; row++)
            {
                var cellValue = worksheet.Cells[row, 1].Text;
                if (!string.IsNullOrEmpty(cellValue))
                {
                    ids.Add(cellValue);
                }
            }
        }

        return ids;
    }

    /// <summary>
    /// Searches GitHub for a specific query.
    /// </summary>
    static async Task<List<SearchResultWithId>> SearchGitHub(string query, string token)
    {
        const int perPage = 100;
        int page = 1;
        var allResults = new List<SearchResultWithId>();
        int retryDelay = 5;

        using (HttpClient client = new HttpClient())
        {
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
            client.DefaultRequestHeaders.Add("User-Agent", "CSharp-Console-App");

            while (true)
            {
                string url = $"https://api.github.com/search/code?q={query}+user:charlesschwab&per_page={perPage}&page={page}";
                HttpResponseMessage response = await client.GetAsync(url);

                if (!response.IsSuccessStatusCode)
                {
                    int statusCode = (int)response.StatusCode;
                    if (statusCode == 429)
                    {
                        Console.WriteLine($"Rate limit hit. Retrying in {retryDelay} sec...");
                        await Task.Delay(retryDelay * 1000);
                        retryDelay = Math.Min(retryDelay * 2, 60);
                        continue;
                    }
                    else
                    {
                        Console.WriteLine($"Error: {response.StatusCode} - {response.ReasonPhrase}");
                        break;
                    }
                }

                string responseBody = await response.Content.ReadAsStringAsync();
                var searchResponse = JsonConvert.DeserializeObject<SearchResponse>(responseBody);

                if (searchResponse?.Items == null || searchResponse.Items.Count == 0)
                {
                    allResults.Add(new SearchResultWithId
                    {
                        Id = query,
                        Repository = null,
                        Path = null,
                        Url = null
                    });
                    break;
                }

                foreach (var result in searchResponse.Items)
                {
                    allResults.Add(new SearchResultWithId
                    {
                        Id = query,
                        Repository = result.Repository,
                        Path = result.Path,
                        Url = result.Url
                    });
                }

                if (searchResponse.Items.Count < perPage)
                {
                    break;
                }

                page++;
            }
        }

        return allResults;
    }

    /// <summary>
    /// Writes search results to an Excel file.
    /// </summary>
    static void WriteResultsToExcel(List<SearchResultWithId> results, string outputFilePath)
    {
        ExcelPackage.LicenseContext = LicenseContext.NonCommercial;

        using (var package = new ExcelPackage())
        {
            var worksheet = package.Workbook.Worksheets.Add("GitHub Results");

            worksheet.Cells[1, 1].Value = "Search ID";
            worksheet.Cells[1, 2].Value = "Repository";
            worksheet.Cells[1, 3].Value = "File Path";
            worksheet.Cells[1, 4].Value = "URL";

            if (results.Count == 0)
            {
                Console.WriteLine("⚠ No results to write.");
            }
            else
            {
                for (int i = 0; i < results.Count; i++)
                {
                    var result = results[i];
                    worksheet.Cells[i + 2, 1].Value = result.Id;
                    worksheet.Cells[i + 2, 2].Value = result.Repository?.FullName ?? "null";
                    worksheet.Cells[i + 2, 3].Value = result.Path ?? "null";
                    worksheet.Cells[i + 2, 4].Value = result.Url ?? "null";
                }
            }

            package.SaveAs(new FileInfo(outputFilePath));
        }
    }
}

// Supporting Classes
class SearchResponse
{
    [JsonProperty("items")]
    public List<SearchResult> Items { get; set; }
}

class SearchResult
{
    [JsonProperty("repository")]
    public Repository Repository { get; set; }

    [JsonProperty("path")]
    public string Path { get; set; }

    [JsonProperty("html_url")]
    public string Url { get; set; }
}

class Repository
{
    [JsonProperty("full_name")]
    public string FullName { get; set; }
}

class SearchResultWithId
{
    public string Id { get; set; }
    public Repository Repository { get; set; }
    public string Path { get; set; }
    public string Url { get; set; }
}
