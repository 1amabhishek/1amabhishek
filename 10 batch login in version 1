using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using Newtonsoft.Json;
using OfficeOpenXml;

class Program
{
    static async Task Main(string[] args)
    {
        // Set the batch size to process multiple IDs together
        int batchSize = 5;

        // Ask for the input file path
        Console.WriteLine("Enter the full path of the Excel file containing the search IDs:");
        string excelFilePath = Console.ReadLine();

        if (!File.Exists(excelFilePath))
        {
            Console.WriteLine("Error: Excel file not found at the specified path.");
            return;
        }

        // Ask for the GitHub token
        Console.WriteLine("Enter your GitHub Personal Access Token:");
        string token = Console.ReadLine();

        if (string.IsNullOrWhiteSpace(token))
        {
            Console.WriteLine("Error: GitHub token cannot be empty.");
            return;
        }

        // Ask for the output directory
        Console.WriteLine("Enter the directory where the output Excel file should be saved:");
        string outputDirectory = Console.ReadLine();

        if (!Directory.Exists(outputDirectory))
        {
            Console.WriteLine("Error: Output directory does not exist.");
            return;
        }

        Console.WriteLine("Reading IDs from Excel file...");
        var ids = ReadIdsFromExcel(excelFilePath);

        Console.WriteLine("Searching GitHub for IDs...");
        var allResults = new List<SearchResultWithId>();

        // Process IDs in batches of 'batchSize' to avoid rate limits
        for (int i = 0; i < ids.Count; i += batchSize)
        {
            var batch = ids.GetRange(i, Math.Min(batchSize, ids.Count - i));
            Console.WriteLine($"Processing batch {i / batchSize + 1}: {string.Join(", ", batch)}");

            // Fetch results for all IDs in the batch concurrently
            var batchResults = await Task.WhenAll(batch.Select(id => SearchGitHub(id, token)));

            // Collect all results
            foreach (var result in batchResults)
            {
                allResults.AddRange(result);
            }
        }

        Console.WriteLine("Writing results to Excel...");
        string outputFilePath = Path.Combine(outputDirectory, "GitHubSearchResults.xlsx");
        WriteResultsToExcel(allResults, outputFilePath);

        Console.WriteLine($"Results written to {outputFilePath}");
    }

    /// <summary>
    /// Reads search IDs from an Excel file.
    /// </summary>
    static List<string> ReadIdsFromExcel(string excelFilePath)
    {
        var ids = new List<string>();

        ExcelPackage.LicenseContext = LicenseContext.NonCommercial;
        using (var package = new ExcelPackage(new FileInfo(excelFilePath)))
        {
            var worksheet = package.Workbook.Worksheets[0];
            int rows = worksheet.Dimension.Rows;

            for (int row = 1; row <= rows; row++)
            {
                var cellValue = worksheet.Cells[row, 1].Text;
                if (!string.IsNullOrEmpty(cellValue))
                {
                    ids.Add(cellValue);
                }
            }
        }

        return ids;
    }

    /// <summary>
    /// Searches GitHub for a specific query and returns matching code results.
    /// Implements rate limit handling using exponential backoff.
    /// </summary>
    static async Task<List<SearchResultWithId>> SearchGitHub(string query, string token)
    {
        const int perPage = 100;
        int page = 1;
        var allResults = new List<SearchResultWithId>();
        int retryDelay = 5; // Initial retry delay in seconds

        using (HttpClient client = new HttpClient())
        {
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
            client.DefaultRequestHeaders.Add("User-Agent", "CSharp-Console-App");

            while (true)
            {
                // GitHub API endpoint with query parameters
                string url = $"https://api.github.com/search/code?q={query}+user:charlesschwab&per_page={perPage}&page={page}";

                HttpResponseMessage response = await client.GetAsync(url);

                if (!response.IsSuccessStatusCode)
                {
                    int statusCode = (int)response.StatusCode;

                    // Handle rate limiting (429 Too Many Requests)
                    if (statusCode == 429)
                    {
                        Console.WriteLine($"Rate limit exceeded. Retrying in {retryDelay} seconds...");
                        await Task.Delay(retryDelay * 1000);
                        retryDelay = Math.Min(retryDelay * 2, 60); // Exponential backoff (max 60s)
                        continue;
                    }
                    else
                    {
                        Console.WriteLine($"Error: {response.StatusCode} - {response.ReasonPhrase}");
                        break;
                    }
                }

                string responseBody = await response.Content.ReadAsStringAsync();
                var searchResponse = JsonConvert.DeserializeObject<SearchResponse>(responseBody);

                if (searchResponse?.Items == null || searchResponse.Items.Count == 0)
                {
                    // If no results, store 'null' for the search ID
                    allResults.Add(new SearchResultWithId
                    {
                        Id = query,
                        Repository = null,
                        Path = null,
                        Url = null
                    });
                    break;
                }

                // Store search results with the associated search ID
                foreach (var result in searchResponse.Items)
                {
                    allResults.Add(new SearchResultWithId
                    {
                        Id = query,
                        Repository = result.Repository,
                        Path = result.Path,
                        Url = result.Url
                    });
                }

                // Stop if fewer results than `perPage` (indicating the last page)
                if (searchResponse.Items.Count < perPage)
                {
                    break;
                }

                page++; // Move to next page
            }
        }

        return allResults;
    }

    /// <summary>
    /// Writes the search results to an Excel file.
    /// </summary>
    static void WriteResultsToExcel(List<SearchResultWithId> results, string outputFilePath)
    {
        ExcelPackage.LicenseContext = LicenseContext.NonCommercial;
        using (var package = new ExcelPackage())
        {
            var worksheet = package.Workbook.Worksheets.Add("GitHub Results");

            // Write headers
            worksheet.Cells[1, 1].Value = "Search ID";
            worksheet.Cells[1, 2].Value = "Repository";
            worksheet.Cells[1, 3].Value = "File Path";
            worksheet.Cells[1, 4].Value = "URL";

            // Write results
            for (int i = 0; i < results.Count; i++)
            {
                var result = results[i];
                worksheet.Cells[i + 2, 1].Value = result.Id;
                worksheet.Cells[i + 2, 2].Value = result.Repository?.FullName ?? "null";
                worksheet.Cells[i + 2, 3].Value = result.Path ?? "null";
                worksheet.Cells[i + 2, 4].Value = result.Url ?? "null";
            }

            package.SaveAs(new FileInfo(outputFilePath));
        }
    }
}

// Supporting Classes
class SearchResponse
{
    [JsonProperty("items")]
    public List<SearchResult> Items { get; set; }
}

class SearchResult
{
    [JsonProperty("repository")]
    public Repository Repository { get; set; }

    [JsonProperty("path")]
    public string Path { get; set; }

    [JsonProperty("html_url")]
    public string Url { get; set; }
}

class Repository
{
    [JsonProperty("full_name")]
    public string FullName { get; set; }
}

class SearchResultWithId
{
    public string Id { get; set; }
    public Repository Repository { get; set; }
    public string Path { get; set; }
    public string Url { get; set; }
}
